import random
import numpy as np
from deap import base, creator, tools, algorithms

class GeneticAlgorithm:
    def __init__(self, config):
        self.config = config
        self.setup_ga()

    def setup_ga(self):
        """Настраиваем генетический алгоритм идентично component_placement.py"""
        if not hasattr(creator, "FitnessMin"):
            creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
        if not hasattr(creator, "Individual"):
            creator.create("Individual", list, fitness=creator.FitnessMin)

        self.toolbox = base.Toolbox()
        
        # Регистрируем функции генерации особей
        self.toolbox.register("individual", self.individual_generator)
        self.toolbox.register("population", tools.initRepeat, list, self.toolbox.individual)
        
        # Регистрируем генетические операторы
        self.toolbox.register("evaluate", self.evaluate)
        self.toolbox.register("mate", tools.cxTwoPoint)
        self.toolbox.register("mutate", tools.mutUniformInt, 
                            low=0, 
                            up=max(self.config["board_width"], self.config["board_height"])-1, 
                            indpb=0.1)
        self.toolbox.register("select", tools.selTournament, tournsize=3)
        self.toolbox.register("mutate_rotation", self.mutRotation, indpb=0.1)

    def individual_generator(self):
        """Генерация особи с учетом размеров платы и компонентов"""
        ind = []
        for comp in self.config["components"]:
            max_x = self.config["board_width"] - comp["width"]
            max_y = self.config["board_height"] - comp["height"]
            x = random.randint(0, max_x) if max_x >= 0 else 0
            y = random.randint(0, max_y) if max_y >= 0 else 0
            rot = random.randint(0, 1)
            ind.extend([x, y, rot])
        return creator.Individual(ind)

    def mutRotation(self, individual, indpb):
        """Мутация поворота компонента"""
        for i in range(2, len(individual), 3):
            if random.random() < indpb:
                individual[i] = 1 - individual[i]
        return individual,

    def evaluate(self, individual):
        """Оценочная функция с проверкой пересечений и расчетом длины соединений"""
        placements = np.array(individual).reshape(-1, 3)
        overlaps = 0
        out_of_board = 0

        # Проверка границ и пересечений
        for i, (x, y, rot) in enumerate(placements):
            comp = self.config["components"][i]
            width = comp["height"] if rot else comp["width"]
            height = comp["width"] if rot else comp["height"]
            if x + width > self.config["board_width"] or y + height > self.config["board_height"]:
                out_of_board += 1

        for i in range(len(self.config["components"])):
            for j in range(i+1, len(self.config["components"])):
                xi, yi, _ = placements[i]
                xj, yj, _ = placements[j]
                wi = self.config["components"][i]["height"] if placements[i][2] else self.config["components"][i]["width"]
                hi = self.config["components"][i]["width"] if placements[i][2] else self.config["components"][i]["height"]
                wj = self.config["components"][j]["height"] if placements[j][2] else self.config["components"][j]["width"]
                hj = self.config["components"][j]["width"] if placements[j][2] else self.config["components"][j]["height"]

                if not (xi + wi <= xj or xj + wj <= xi or yi + hi <= yj or yj + hj <= yi):
                    overlaps += 1

        # Расчет длины соединений
        centers = []
        for i, (x, y, rot) in enumerate(placements):
            comp = self.config["components"][i]
            width = comp["height"] if rot else comp["width"]
            height = comp["width"] if rot else comp["height"]
            centers.append((x + width/2, y + height/2))
        
        total_wirelength = 0.0
        for a, b in self.config["connections"]:
            dx = centers[a][0] - centers[b][0]
            dy = centers[a][1] - centers[b][1]
            total_wirelength += (dx**2 + dy**2)**0.5

        penalty = overlaps * 1000 + out_of_board * 5000
        return (total_wirelength + penalty,)

    def visualize_placement(self, individual, gen=None):
        """Визуализация платы как в component_placement.py"""
        placements = np.array(individual).reshape(-1, 3)
        cell_width = 3
        empty_cell = " " * cell_width
        board = np.full((self.config["board_height"], self.config["board_width"]), empty_cell, dtype=f'U{cell_width}')
        
        if gen is not None:
            print(f"\n--- Поколение {gen} ---")
            print("Целевая функция:", individual.fitness.values[0])

        for idx, (x, y, rot) in enumerate(placements):
            comp = self.config["components"][idx]
            width = comp["height"] if rot else comp["width"]
            height = comp["width"] if rot else comp["height"]
            
            if x + width > self.config["board_width"] or y + height > self.config["board_height"]:
                print(f"Компонент {idx+1} выходит за границы! [X={x}-{x+width}, Y={y}-{y+height}]")
                continue
                
            symbol = f"C{idx+1}" + ("'" if rot else " ")
            for dy in range(height):
                for dx in range(width):
                    if board[y + dy, x + dx] == empty_cell:
                        board[y + dy, x + dx] = symbol.ljust(cell_width)
                    else:
                        board[y + dy, x + dx] = "XX "

        print("\nВизуализация платы:")
        for row in board:
            print("|" + "|".join(row) + "|")

    def run(self, log=None):
        """Запуск алгоритма с визуализацией как в оригинале"""
        if len(self.config["components"]) == 0:
            raise ValueError("Нет компонентов для размещения")

        population = self.toolbox.population(n=self.config["population_size"])
        
        # Вычисляем fitness для начальной популяции
        for ind in population:
            ind.fitness.values = self.toolbox.evaluate(ind)

        # Визуализация начальной популяции
        best_ind = tools.selBest(population, k=1)[0]
        self.visualize_placement(best_ind, gen=0)

        # Основной цикл эволюции
        for gen in range(1, self.config["generations"] + 1):
            # Селекция и создание потомков
            offspring = self.toolbox.select(population, len(population))
            offspring = list(map(self.toolbox.clone, offspring))

            # Кроссовер
            for child1, child2 in zip(offspring[::2], offspring[1::2]):
                if random.random() < self.config["cxpb"]:
                    self.toolbox.mate(child1, child2)
                    del child1.fitness.values
                    del child2.fitness.values

            # Мутация
            for mutant in offspring:
                if random.random() < self.config["mutpb"]:
                    self.toolbox.mutate(mutant)
                    self.toolbox.mutate_rotation(mutant)
                    del mutant.fitness.values

            # Оценка новых особей
            invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
            fitnesses = map(self.toolbox.evaluate, invalid_ind)
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = fit

            population[:] = offspring

            # Визуализация на указанных шагах
            if gen in self.config["visualization_steps"]:
                best_ind = tools.selBest(population, k=1)[0]
                self.visualize_placement(best_ind, gen=gen)

        # Финальная визуализация
        best_individual = tools.selBest(population, k=1)[0]
        print("\n--- Финальный результат ---")
        self.visualize_placement(best_individual)
        print("Значение функции:", best_individual.fitness.values[0])

        return population, None